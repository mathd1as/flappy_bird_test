{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common\";\nconst _c0 = [\"gameCanvas\"];\nfunction GameComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4)(1, \"h1\");\n    i0.ɵɵtext(2, \"Flappy Bird\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"p\");\n    i0.ɵɵtext(4, \"Press Space to Start\");\n    i0.ɵɵelementEnd()();\n  }\n}\nexport class GameComponent {\n  constructor() {\n    this.bird = {\n      x: 50,\n      y: 200,\n      velocity: 0,\n      gravity: 0.5,\n      jump: -8,\n      size: 20\n    };\n    this.pipes = [];\n    this.score = 0;\n    this.gameOver = false;\n    this.gameStarted = false;\n    this.animationFrame = null;\n  }\n  ngOnInit() {\n    this.initGame();\n  }\n  initGame() {\n    this.bird.y = 200;\n    this.bird.velocity = 0;\n    this.pipes = [];\n    this.score = 0;\n    this.gameOver = false;\n    this.gameStarted = false;\n  }\n  onKeyDown(event) {\n    if (event.code === 'Space') {\n      if (!this.gameStarted) {\n        this.gameStarted = true;\n        this.startGame();\n      } else if (!this.gameOver) {\n        this.bird.velocity = this.bird.jump;\n      } else {\n        this.initGame();\n        this.startGame();\n      }\n    }\n  }\n  startGame() {\n    this.animate();\n    this.generatePipes();\n  }\n  generatePipes() {\n    if (this.gameOver) return;\n    const gapHeight = 150;\n    const gapY = Math.random() * (400 - gapHeight);\n    this.pipes.push({\n      x: 400,\n      gapY: gapY\n    });\n    setTimeout(() => this.generatePipes(), 2000);\n  }\n  animate() {\n    if (this.gameOver) return;\n    this.ctx = this.canvasRef.nativeElement.getContext('2d');\n    this.ctx.clearRect(0, 0, 400, 600);\n    // Update bird position\n    this.bird.velocity += this.bird.gravity;\n    this.bird.y += this.bird.velocity;\n    // Draw bird\n    this.ctx.fillStyle = '#FFD700';\n    this.ctx.beginPath();\n    this.ctx.arc(this.bird.x, this.bird.y, this.bird.size, 0, Math.PI * 2);\n    this.ctx.fill();\n    // Update and draw pipes\n    this.pipes.forEach((pipe, index) => {\n      pipe.x -= 2;\n      // Draw pipes\n      this.ctx.fillStyle = '#2ecc71';\n      this.ctx.fillRect(pipe.x, 0, 50, pipe.gapY);\n      this.ctx.fillRect(pipe.x, pipe.gapY + 150, 50, 600 - (pipe.gapY + 150));\n      // Check collision\n      if (this.checkCollision(pipe)) {\n        this.gameOver = true;\n      }\n      // Update score\n      if (pipe.x + 50 < this.bird.x && !pipe.passed) {\n        this.score++;\n        pipe.passed = true;\n      }\n      // Remove off-screen pipes\n      if (pipe.x < -50) {\n        this.pipes.splice(index, 1);\n      }\n    });\n    // Draw score\n    this.ctx.fillStyle = '#000';\n    this.ctx.font = '24px Arial';\n    this.ctx.fillText(`Score: ${this.score}`, 10, 30);\n    // Check if bird is out of bounds\n    if (this.bird.y < 0 || this.bird.y > 600) {\n      this.gameOver = true;\n    }\n    // Draw game over message\n    if (this.gameOver) {\n      this.ctx.fillStyle = '#000';\n      this.ctx.font = '48px Arial';\n      this.ctx.fillText('Game Over!', 100, 300);\n      this.ctx.font = '24px Arial';\n      this.ctx.fillText('Press Space to Restart', 80, 350);\n    }\n    this.animationFrame = requestAnimationFrame(() => this.animate());\n  }\n  checkCollision(pipe) {\n    return this.bird.x + this.bird.size > pipe.x && this.bird.x - this.bird.size < pipe.x + 50 && (this.bird.y - this.bird.size < pipe.gapY || this.bird.y + this.bird.size > pipe.gapY + 150);\n  }\n  ngOnDestroy() {\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n    }\n  }\n  static {\n    this.ɵfac = function GameComponent_Factory(t) {\n      return new (t || GameComponent)();\n    };\n  }\n  static {\n    this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: GameComponent,\n      selectors: [[\"app-game\"]],\n      viewQuery: function GameComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvasRef = _t.first);\n        }\n      },\n      hostBindings: function GameComponent_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function GameComponent_keydown_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          }, false, i0.ɵɵresolveWindow);\n        }\n      },\n      decls: 4,\n      vars: 1,\n      consts: [[1, \"game-container\"], [\"width\", \"400\", \"height\", \"600\"], [\"gameCanvas\", \"\"], [\"class\", \"instructions\", 4, \"ngIf\"], [1, \"instructions\"]],\n      template: function GameComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵelement(1, \"canvas\", 1, 2);\n          i0.ɵɵtemplate(3, GameComponent_div_3_Template, 5, 0, \"div\", 3);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"ngIf\", !ctx.gameStarted);\n        }\n      },\n      dependencies: [i1.NgIf],\n      styles: [\".game-container[_ngcontent-%COMP%] {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  height: 100vh;\\n  background-color: #87CEEB;\\n}\\n\\ncanvas[_ngcontent-%COMP%] {\\n  border: 2px solid #000;\\n  background-color: #87CEEB;\\n}\\n\\n.instructions[_ngcontent-%COMP%] {\\n  position: absolute;\\n  text-align: center;\\n  color: white;\\n  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);\\n}\\n\\n.instructions[_ngcontent-%COMP%]   h1[_ngcontent-%COMP%] {\\n  font-size: 48px;\\n  margin-bottom: 20px;\\n}\\n\\n.instructions[_ngcontent-%COMP%]   p[_ngcontent-%COMP%] {\\n  font-size: 24px;\\n}\"]\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}